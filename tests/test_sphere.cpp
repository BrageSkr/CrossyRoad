
#include "sphere.hpp"

#define CATCH_CONFIG_MAIN

#include <catch2/catch.hpp>


TEST_CASE("Sphere Movement") {
    /* sphere player(0);
   keyInput inputTest{false, false, false, false, false};
   int hexColor = 0x0000FF;
   bool hasCollision = false;

 SECTION("Sphere moves forwards when input.up is true") {
       inputTest.up = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.x == Approx(0.1f));
   }

   SECTION("Sphere moves backwards when input.down is true") {
       inputTest.down = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.x == Approx(-0.1f));
   }

   SECTION("Sphere moves right when input.right is true") {
       inputTest.right = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.z == Approx(0.1f));
   }

   SECTION("Sphere moves left when input.left is true") {
       inputTest.left = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.z == Approx(-0.1f));
   }

   SECTION("Sphere is reset when input.reset is true") {
       inputTest.reset = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.x == Approx(0.0f));
       CHECK(s.mesh()->position.z == Approx(0.0f));
   }

   SECTION("Sphere is reset when hasCollision is true") {
       hasCollision = true;
       s.update(1.0f, inputTest, hexColor, hasCollision);
       CHECK(s.mesh()->position.x == Approx(0.0f));
       CHECK(s.mesh()->position.z == Approx(0.0f));
   }*/

  CHECK(0==0);

}