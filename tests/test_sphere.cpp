
#include "sphere.hpp"

#define CATCH_CONFIG_MAIN

#include <catch2/catch.hpp>


TEST_CASE("Sphere Movement") {
  /*  sphere s(0.0f);
    keyInput input{false, false, false, false, false};
    int hexColor = 0x0000FF;
    bool hasCollision = false;

    SECTION("Sphere moves forwards when input.up is true") {
        input.up = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.x == Approx(0.1f));
    }

    SECTION("Sphere moves backwards when input.down is true") {
        input.down = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.x == Approx(-0.1f));
    }

    SECTION("Sphere moves right when input.right is true") {
        input.right = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.z == Approx(0.1f));
    }

    SECTION("Sphere moves left when input.left is true") {
        input.left = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.z == Approx(-0.1f));
    }

    SECTION("Sphere is reset when input.reset is true") {
        input.reset = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.x == Approx(0.0f));
        CHECK(s.mesh()->position.z == Approx(0.0f));
    }

    SECTION("Sphere is reset when hasCollision is true") {
        hasCollision = true;
        s.update(1.0f, input, hexColor, hasCollision);
        CHECK(s.mesh()->position.x == Approx(0.0f));
        CHECK(s.mesh()->position.z == Approx(0.0f));
    }
*/
  CHECK(0==0);

}